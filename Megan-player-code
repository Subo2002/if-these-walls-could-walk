extends [CharacterBody2D]

# === PLAYER STATS ===
var health: int = 100
var max_health: int = 100

var light_fruit: int = 100
var light_fruit_max: int = 100

# === MOVEMENT ===
const WALK_SPEED: float = 60
const JUMP_FORCE: float = -180
const GRAVITY: float = 350
const MAX_FALL_SPEED: float = 300

# === ATTACK ===
var can_attack: bool = true
const ATTACK_COOLDOWN: float = 1.2

# === TORCH SYSTEM ===
var torch_on: bool = false
const TORCH_DRAIN_RATE: float = 5.0              # Units of Light Fruit per drain tick
const TORCH_MINIMUM_FRUIT: int = 10              # Can't toggle on if under this
const FATIGUE_INTERVAL: float = 0.2              # Drain interval in seconds

# === UI REFERENCES ===
@onready var ui_health_bar = $"../UI/HealthBar"
@onready var ui_light_bar = $"../UI/LightFruitBar"

# === NODE REFERENCES ===
@onready var sprite = $AnimatedSprite2D
@onready var torch = $Light2D
@onready var attack_timer = $Timer
@onready var fatigue_timer = $torch_fatigue_timer
@onready var attack_hitbox = $AttackHitbox

# === SOUND EFFECTS ===
@onready var sfx_attack = $attack_sound
@onready var sfx_torch_on = $torch_on_sound
@onready var sfx_torch_off = $torch_off_sound
@onready var sfx_burnout = $torch_burnout_sound

# === PARTICLES ===
@onready var p_attack = $attack_particles
@onready var p_torch = $torch_particles

# === INITIAL SETUP ===
func _ready():
	torch.visible = false                          # Start with torch off
	attack_hitbox.monitoring = false               # Hitbox disabled until attack
	fatigue_timer.wait_time = FATIGUE_INTERVAL     # How fast torch drains
	fatigue_timer.one_shot = false

# === MAIN LOOP ===
func _physics_process(delta):
	handle_gravity(delta)
	handle_movement()
	handle_animations()
	move_and_slide()

	# Torch and attack input
	if Input.is_action_just_pressed("attack") and can_attack:
		perform_attack()

	if Input.is_action_just_pressed("torch_toggle"):
		if not torch_on and light_fruit > TORCH_MINIMUM_FRUIT:
			enable_torch()
		else:
			disable_torch()

# === UI BAR UPDATES ===
func _process(delta):
	ui_health_bar.value = health
	ui_light_bar.value = light_fruit

# === FALLING LOGIC ===
func handle_gravity(delta):
	if not is_on_floor():
		velocity.y += GRAVITY * delta
		if velocity.y > MAX_FALL_SPEED:
			velocity.y = MAX_FALL_SPEED

# === HORIZONTAL + JUMP INPUT ===
func handle_movement():
	var input_direction = Input.get_action_strength("ui_right") - Input.get_action_strength("ui_left")
	velocity.x = input_direction * WALK_SPEED

	if input_direction != 0:
		sprite.flip_h = input_direction < 0

	if Input.is_action_just_pressed("ui_up") and is_on_floor():
		velocity.y = JUMP_FORCE
		sprite.play("jump")

# === ANIMATION HANDLING ===
func handle_animations():
	if is_on_floor():
		if velocity.x != 0:
			sprite.play("walk")
		else:
			sprite.play("idle")

# === ATTACK ACTION ===
func perform_attack():
	can_attack = false
	sprite.play("attack")
	attack_hitbox.monitoring = true
	sfx_attack.play()
	p_attack.restart()
	attack_timer.start(ATTACK_COOLDOWN)

# === RE-ENABLE ATTACK ===
func _on_Timer_timeout():
	can_attack = true
	attack_hitbox.monitoring = false

# === TORCH DRAIN PER INTERVAL ===
func _on_torch_fatigue_timer_timeout():
	if torch_on:
		light_fruit -= TORCH_DRAIN_RATE
		if light_fruit <= 0:
			light_fruit = 0
			sfx_burnout.play()
			disable_torch()

# === TURN TORCH ON ===
func enable_torch():
	torch_on = true
	torch.visible = true
	sfx_torch_on.play()
	p_torch.restart()
	fatigue_timer.start()

# === TURN TORCH OFF ===
func disable_torch():
	if torch_on:
		sfx_torch_off.play()
		p_torch.restart()
	torch_on = false
	torch.visible = false
	fatigue_timer.stop()

# === DAMAGE HANDLER ===
func take_damage(amount: int):
	health -= amount
	if health < 0:
		health = 0
		die()

func die():
	queue_free() # Replace with custom death behavior

# === ATTACK HITBOX: DAMAGE ENEMIES ===
func _on_AttackHitbox_body_entered(body):
	if body.is_in_group("enemies"):
		body.take_damage(10)

